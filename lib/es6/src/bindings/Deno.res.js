// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Stdlib_Exn from "@rescript/runtime/lib/es6/Stdlib_Exn.js";
import * as Stdlib_Option from "@rescript/runtime/lib/es6/Stdlib_Option.js";
import * as Primitive_exceptions from "@rescript/runtime/lib/es6/Primitive_exceptions.js";

function getWithDefault(key, $$default) {
  let v = Deno.env.get(key);
  if (v !== undefined) {
    return v;
  } else {
    return $$default;
  }
}

let Env = {
  getWithDefault: getWithDefault
};

let decoder = new TextDecoder();

function stdoutText(output) {
  return decoder.decode(output.stdout);
}

function stderrText(output) {
  return decoder.decode(output.stderr);
}

function $$new(cmd, argsOpt, cwdOpt) {
  let args = argsOpt !== undefined ? argsOpt : [];
  let cwd = cwdOpt !== undefined ? cwdOpt : "";
  if (cwd !== "") {
    return new (Deno.Command)(cmd, {
      args: args,
      cwd: cwd,
      stdout: "piped",
      stderr: "piped"
    });
  } else {
    return new (Deno.Command)(cmd, {
      args: args,
      stdout: "piped",
      stderr: "piped"
    });
  }
}

async function run(binary, args) {
  let cmd = $$new(binary, args, undefined);
  let result = await cmd.output();
  return [
    result.code,
    decoder.decode(result.stdout),
    decoder.decode(result.stderr)
  ];
}

let Command = {
  decoder: decoder,
  stdoutText: stdoutText,
  stderrText: stderrText,
  $$new: $$new,
  run: run
};

async function get(url, headersOpt) {
  let headers = headersOpt !== undefined ? headersOpt : ({});
  try {
    let response = await fetch(url, {
      method: "GET",
      headers: headers
    });
    if (!response.ok) {
      return {
        TAG: "Error",
        _0: `HTTP ` + response.status.toString() + `: ` + response.statusText
      };
    }
    let data = await response.json();
    return {
      TAG: "Ok",
      _0: data
    };
  } catch (raw_e) {
    let e = Primitive_exceptions.internalToException(raw_e);
    if (e.RE_EXN_ID === Stdlib_Exn.$$Error) {
      return {
        TAG: "Error",
        _0: Stdlib_Option.getOr(e._1.message, "Unknown error")
      };
    }
    throw e;
  }
}

async function post(url, body, headersOpt) {
  let headers = headersOpt !== undefined ? headersOpt : ({});
  try {
    let response = await fetch(url, {
      method: "POST",
      headers: headers,
      body: body
    });
    if (!response.ok) {
      return {
        TAG: "Error",
        _0: `HTTP ` + response.status.toString() + `: ` + response.statusText
      };
    }
    let data = await response.json();
    return {
      TAG: "Ok",
      _0: data
    };
  } catch (raw_e) {
    let e = Primitive_exceptions.internalToException(raw_e);
    if (e.RE_EXN_ID === Stdlib_Exn.$$Error) {
      return {
        TAG: "Error",
        _0: Stdlib_Option.getOr(e._1.message, "Unknown error")
      };
    }
    throw e;
  }
}

async function $$delete(url, headersOpt) {
  let headers = headersOpt !== undefined ? headersOpt : ({});
  try {
    let response = await fetch(url, {
      method: "DELETE",
      headers: headers
    });
    if (response.ok) {
      return {
        TAG: "Ok",
        _0: Object.fromEntries([[
            "success",
            true
          ]])
      };
    } else {
      return {
        TAG: "Error",
        _0: `HTTP ` + response.status.toString() + `: ` + response.statusText
      };
    }
  } catch (raw_e) {
    let e = Primitive_exceptions.internalToException(raw_e);
    if (e.RE_EXN_ID === Stdlib_Exn.$$Error) {
      return {
        TAG: "Error",
        _0: Stdlib_Option.getOr(e._1.message, "Unknown error")
      };
    }
    throw e;
  }
}

let Fetch = {
  get: get,
  post: post,
  $$delete: $$delete
};

export {
  Env,
  Command,
  Fetch,
}
/* decoder Not a pure module */
